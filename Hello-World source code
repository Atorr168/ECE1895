// Dual MPU6050 with X-axis trigger + health monitoring (identify which MPU fails)
// Now also requires forward DISPLACEMENT relative to initial pose, not just accel.
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <math.h>

// ----- I2C ADDRESSES -----
const uint8_t ADDR_A = 0x68;   // AD0=GND
const uint8_t ADDR_B = 0x69;   // AD0=VCC

// ----- SENSORS -----
Adafruit_MPU6050 mpuA;
Adafruit_MPU6050 mpuB;

// ----- CONFIG -----
float alpha = 0.95f;             // gravity LPF factor
const uint16_t HOLD_MS = 150;    // LED hold after trigger (ms)

// X-axis thresholds (m/s^2)
const float THRESH_X_ON_MS2  = 10.0f;  // accel trigger
const float THRESH_X_OFF_MS2 = 6.0f;   // accel release

// NEW: Position thresholds (meters) â€“ relative forward displacement (+X)
const float POS_ON_M  = 0.04f;  // ~4 cm forward required to trigger
const float POS_OFF_M = 0.02f;  // ~2 cm (hysteresis)

// Integration drift control (time constants, seconds)
// Smaller tau => stronger decay
const float TAU_VEL_S = 0.25f;  // velocity leak (quarter-second memory)
const float TAU_POS_S = 2.0f;   // position leak (multi-second memory)
const float DT_MAX_S  = 0.05f;  // dt clamp for robustness (~20 Hz)

// Optional hard clamps to keep integrator bounded
const float VEL_CLAMP = 10.0f;  // m/s (well above human punch)
const float POS_CLAMP = 0.30f;  // m   (30 cm envelope)

// LEDs
const uint8_t LED_BLINK = 8;     // startup blink

// Forward (+X) LEDs only
const uint8_t LED_A_FWD = 6;     // forward for MPU A
const uint8_t LED_B_FWD = 7;     // forward for MPU B

// Health monitor
const uint8_t WHO_AM_I_REG   = 0x75;
const uint8_t WHO_AM_I_VALUE = 0x68;  // expected for MPU6050
const uint8_t HEALTH_FAIL_LIMIT = 3;
const uint16_t HEALTH_PERIOD_MS = 500;
const uint16_t FAIL_BLINK_MS = 100;

// ----- STATE -----
struct GravState {
  bool g_init = false;
  float gx = 0, gy = 0, gz = 0;    // gravity estimate
  // NEW: simple 1D kinematics along +X
  float vx = 0;                    // forward velocity (m/s)
  float px = 0;                    // forward displacement from start (m)
  unsigned long tLast = 0;         // last update time (ms)

  bool punch_on = false;
  unsigned long tPunch = 0;
};

GravState sA, sB;

struct HealthState {
  bool healthy = true;
  uint8_t failCount = 0;
  unsigned long lastCheck = 0;
};
HealthState hA, hB;

// ----- HELPERS -----
static inline float mag3(float x, float y, float z) {
  return sqrtf(x*x + y*y + z*z);
}

bool i2cReadReg8(uint8_t addr, uint8_t reg, uint8_t &val) {
  Wire.beginTransmission(addr);
  Wire.write(reg);
  uint8_t tx = Wire.endTransmission(false);
  if (tx != 0) return false;

  uint8_t n = Wire.requestFrom((int)addr, 1, (int)true);
  if (n != 1) return false;

  val = Wire.read();
  return true;
}

void checkHealth(uint8_t addr, HealthState &hs, const char *tag) {
  uint8_t v = 0x00;
  bool ok = i2cReadReg8(addr, WHO_AM_I_REG, v) && (v == WHO_AM_I_VALUE);

  if (!ok) {
    if (hs.failCount < 255) hs.failCount++;
    if (hs.failCount >= HEALTH_FAIL_LIMIT && hs.healthy) {
      hs.healthy = false;
      Serial.print(tag); Serial.println(" unhealthy (WHO_AM_I failed)");
    }
  } else {
    if (!hs.healthy) {
      Serial.print(tag); Serial.println(" recovered");
    }
    hs.healthy = true;
    hs.failCount = 0;
  }
}

bool beginMPU(Adafruit_MPU6050 &mpu, uint8_t addr, const char *tag) {
  if (!mpu.begin(addr)) {
    Serial.print(tag); Serial.println(" begin() failed");
    return false;
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  return true;
}

// ---- LED helpers ----
inline bool blinkFast(unsigned long now) { return ((now / 100) % 2) == 0; }

void setFwdLED(bool isA, bool on, unsigned long now) {
  bool ledState = on && blinkFast(now);  // blink while active
  if (isA) digitalWrite(LED_A_FWD, ledState ? HIGH : LOW);
  else     digitalWrite(LED_B_FWD, ledState ? HIGH : LOW);
}

void clearFwdLEDs(bool isA) {
  if (isA) digitalWrite(LED_A_FWD, LOW);
  else     digitalWrite(LED_B_FWD, LOW);
}

void seedGravity(Adafruit_MPU6050 &mpu, GravState &st, const char *tag) {
  sensors_event_t a, g, temp;
  if (!st.g_init) {
    mpu.getEvent(&a, &g, &temp);
    st.gx = a.acceleration.x;
    st.gy = a.acceleration.y;
    st.gz = a.acceleration.z;
    st.vx = 0.0f;
    st.px = 0.0f;
    st.tLast = millis();
    st.g_init = true;
    Serial.print(tag); Serial.println(" gravity/kinematics seeded");
  }
}

// ------- 1D kinematics helpers (decay factors per dt) -------
static inline float decayFactor(float dt_s, float tau_s) {
  // Protect against tiny/huge dt
  if (tau_s <= 0.0f) return 0.0f;
  if (dt_s < 0.0f) dt_s = 0.0f;
  if (dt_s > 5.0f) dt_s = 5.0f;
  return expf(-dt_s / tau_s);
}

// Process one sensor when healthy: update LPF, integrate X kinematics,
// and trigger only if forward position AND forward accel exceed thresholds.
void punch(Adafruit_MPU6050 &mpu, GravState &st, const char *tag, bool isA) {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  unsigned long now = millis();
  if (!st.g_init) {
    st.gx = a.acceleration.x; st.gy = a.acceleration.y; st.gz = a.acceleration.z;
    st.vx = 0.0f; st.px = 0.0f;
    st.tLast = now;
    st.g_init = true;
  }

  // dt (seconds), clamped
  float dt = (now - st.tLast) * 0.001f;
  if (dt > DT_MAX_S) dt = DT_MAX_S;
  st.tLast = now;

  // Gravity LPF
  st.gx = alpha * st.gx + (1.0f - alpha) * a.acceleration.x;
  st.gy = alpha * st.gy + (1.0f - alpha) * a.acceleration.y;
  st.gz = alpha * st.gz + (1.0f - alpha) * a.acceleration.z;

  // Linear acceleration (m/s^2)
  float lx = a.acceleration.x - st.gx;
  float ly = a.acceleration.y - st.gy;
  float lz = a.acceleration.z - st.gz;
  float amag = mag3(lx, ly, lz);

  // --- 1D forward kinematics with decay to limit drift ---
  float kv = decayFactor(dt, TAU_VEL_S);
  float kp = decayFactor(dt, TAU_POS_S);

  // Leak previous state (decay), then integrate
  st.vx = st.vx * kv + lx * dt;
  // Bound velocity to keep insane spikes from accumulating
  if (st.vx >  VEL_CLAMP) st.vx =  VEL_CLAMP;
  if (st.vx < -VEL_CLAMP) st.vx = -VEL_CLAMP;

  st.px = st.px * kp + st.vx * dt;
  if (st.px >  POS_CLAMP) st.px =  POS_CLAMP;
  if (st.px < -POS_CLAMP) st.px = -POS_CLAMP;

  // --- Trigger logic: require BOTH forward accel and forward position ---
  if (!st.punch_on && (lx > THRESH_X_ON_MS2) && (st.px > POS_ON_M)) {
    st.punch_on = true;
    st.tPunch = now;
  } else if (st.punch_on &&
             (now - st.tPunch > HOLD_MS) &&
             ((lx < THRESH_X_OFF_MS2) || (st.px < POS_OFF_M))) {
    st.punch_on = false;
    // Optional: reset integrators a bit to avoid immediate retriggering
    st.vx *= 0.2f;
    st.px *= 0.5f;
  } else {
    // If not punching, gently relax back toward zero to reduce bias
    if (!st.punch_on) {
      st.vx *= kv;
      st.px *= kp;
    }
  }

  // Drive LED (blink while active)
  if (st.punch_on) setFwdLED(isA, true, now);
  else             clearFwdLEDs(isA);

  // Debug
  Serial.print(tag);
  Serial.print(" lx:"); Serial.print(lx,2);
  Serial.print(" ly:"); Serial.print(ly,2);
  Serial.print(" lz:"); Serial.print(lz,2);
  Serial.print(" | |a|:"); Serial.print(amag,2);
  Serial.print(" | vx:"); Serial.print(st.vx,2);
  Serial.print(" px:");  Serial.print(st.px*100.0f,1); // cm
  if (st.punch_on) Serial.print("  <-- +X PUNCH (accel+pos)");
  Serial.println();
}

void setup() {
  Serial.begin(115200);
  Wire.begin();

  pinMode(LED_BLINK, OUTPUT);
  pinMode(LED_A_FWD, OUTPUT);
  pinMode(LED_B_FWD, OUTPUT);
  clearFwdLEDs(true);
  clearFwdLEDs(false);

  // Startup blink
  for (int i=0; i<3; i++) {
    digitalWrite(LED_BLINK, HIGH); delay(200);
    digitalWrite(LED_BLINK, LOW); delay(200);
  }

  // Initialize MPUs
  bool okA = beginMPU(mpuA, ADDR_A, "MPU A");
  bool okB = beginMPU(mpuB, ADDR_B, "MPU B");

  checkHealth(ADDR_A, hA, "MPU A");
  checkHealth(ADDR_B, hB, "MPU B");

  if (!okA) { hA.healthy = false; hA.failCount = HEALTH_FAIL_LIMIT; }
  if (!okB) { hB.healthy = false; hB.failCount = HEALTH_FAIL_LIMIT; }

  // Seed gravity/kinematics immediately for healthy sensors
  if (hA.healthy) seedGravity(mpuA, sA, "A");
  if (hB.healthy) seedGravity(mpuB, sB, "B");

  Serial.println("Health monitor active: WHO_AM_I checks + fast-blink on failure");
  delay(100);
}

void loop() {
  unsigned long now = millis();

  // Periodic health checks
  if (now - hA.lastCheck >= HEALTH_PERIOD_MS) {
    hA.lastCheck = now;
    checkHealth(ADDR_A, hA, "MPU A");
  }
  if (now - hB.lastCheck >= HEALTH_PERIOD_MS) {
    hB.lastCheck = now;
    checkHealth(ADDR_B, hB, "MPU B");
  }

  // Failure indication: blink forward LEDs
  bool aFailBlink = (!hA.healthy) && ((now / FAIL_BLINK_MS) % 2);
  bool bFailBlink = (!hB.healthy) && ((now / FAIL_BLINK_MS) % 2);

  if (!hA.healthy) digitalWrite(LED_A_FWD, aFailBlink ? HIGH : LOW);
  if (!hB.healthy) digitalWrite(LED_B_FWD, bFailBlink ? HIGH : LOW);

  // Only process healthy sensors for punch/X-axis logic
  if (hA.healthy) punch(mpuA, sA, "A", true);
  if (hB.healthy) punch(mpuB, sB, "B", false);

  delay(20);
}
