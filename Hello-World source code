// Dual MPU6050 with X-axis trigger + health monitoring (identify which MPU fails)
// Now also requires forward DISPLACEMENT relative to initial pose, not just accel.
// FIXES:
//  - Proper per-sensor 3×3 orientation mapping (no ad-hoc X flip)
//  - Averaged gravity seed
//  - Freeze gravity LPF during high dynamics so it won't "learn" the shove
//  - Separate kinematics for punch vs. pull-back (longer memory for pull-back)

#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <math.h>


// ==== 1) Types FIRST (before any function that uses them) ====
struct GravState {
  bool g_init = false;
  float gx = 0, gy = 0, gz = 0;
  float vx = 0, px = 0;
  float vx_pb = 0, pbx = 0;
  unsigned long tLast = 0;
  bool punch_on = false;
  unsigned long tPunch = 0;
  float lx_last = 0.0f;
};

struct HealthState {
  bool healthy = true;
  uint8_t failCount = 0;
  unsigned long lastCheck = 0;
};

// --- Demo phases ---
enum DemoPhase : uint8_t { DEMO_IDLE = 0, DEMO_ON, DEMO_BREAK, DEMO_DONE };
enum DemoTarget : uint8_t { TGT_A = 0, TGT_B = 1, TGT_PB = 2 };

// ==== 2) Globals that use those types ====
bool game_started = false;
GravState sA, sB;
HealthState hA, hB;


// ----- I2C ADDRESSES -----
const uint8_t ADDR_A = 0x68;   // AD0=GND
const uint8_t ADDR_B = 0x69;   // AD0=VCC

// ----- SENSORS -----
Adafruit_MPU6050 mpuA;
Adafruit_MPU6050 mpuB;

// ----- CONFIG -----
float alpha = 0.98f; // gravity LPF factor
const uint16_t HOLD_MS = 150;    // LED hold after trigger (ms)

// X-axis thresholds (m/s^2)
const float THRESH_X_ON_MS2  = 12.0f;
const float THRESH_X_OFF_MS2 = 1.2f;

// Punch displacement gates (meters, forward = +X)
const float POS_ON_M  = 0.03f;
const float POS_OFF_M = 0.015f;

// Integration drift control (time constants, seconds)
const float TAU_VEL_S = 0.25f;  // velocity leak [punch]
const float TAU_POS_S = 2.0f;   // position leak [punch]

// >>> pull-back: longer memory so slow moves accumulate
const float TAU_VEL_PB_S = 1.0f; // pull-back velocity leak
const float TAU_POS_PB_S = 4.0f; // pull-back position leak

// dt clamp for robustness (~20 Hz)
const float DT_MAX_S  = 0.05f;

// Optional hard clamps to keep integrator bounded
const float VEL_CLAMP = 10.0f;  // m/s
const float POS_CLAMP = 0.30f;  // m   (30 cm envelope)

// --- Start button ---
const uint8_t BTN_START   = 12;     // tie to GND when pressed
const uint16_t DEBOUNCE_MS = 30;

bool btnPrev = true;                // INPUT_PULLUP: true = released
unsigned long lastBtnChange = 0;

inline bool startPressed() {
  bool s = (digitalRead(BTN_START) == LOW);
  if (s != btnPrev && (millis() - lastBtnChange) > DEBOUNCE_MS) {
    btnPrev = s; lastBtnChange = millis();
    if (s) return true;             // rising edge (press)
  }
  return false;
}

// const uint8_t LED_PULL_BACK = 5;
const uint8_t LED_PASS = 6;     // temp led for pass fail, and MPU A init
const uint8_t LED_FAIL = 7;     // temp led for pass fail, and MPU B init

// BCD bus (share to both 7447s)
const uint8_t BCD_PINS[4] = {2, 3, 4, 8}; // A,B,C,D (choose any free pins)

// Per-digit enables to 7447 BI/ pins (active LOW to blank)
const uint8_t EN_A = 13;  // -> BI/_A
const uint8_t EN_B = 11;  // -> BI/_B

// Health monitor
const uint8_t WHO_AM_I_REG   = 0x75;
const uint8_t WHO_AM_I_VALUE = 0x68;  // expected for MPU6050
const uint8_t HEALTH_FAIL_LIMIT = 3;
const uint16_t HEALTH_PERIOD_MS = 500;
const uint16_t FAIL_BLINK_MS = 100;

// --- Guard-pose option (Y/Z agreement). Leave OFF to use reverse-accel-only ---
const bool USE_GUARD_POSE = false;   // <- set true to re-enable Y/Z checks

// Guard-pose gating (angle + hysteresis + smoothing) — very loose cone
const float GUARD_COS_ON  = 0.35f;
const float GUARD_COS_OFF = 0.25f;
const float GUARD_COS_ALPHA = 0.80f;  // LPF on cos(angle)

bool backA_on = false, backB_on = false;
unsigned long tBackA = 0, tBackB = 0;

// Reverse-punch (backward accel) thresholds — much lower than punch
const float BACK_ON_MS2  = -3.5f;   // trigger when lx <= this
const float BACK_OFF_MS2 = -1.5f;   // release when lx >= this
const uint16_t BACK_HOLD_MS = 120;  // minimal "active" hold to get overlap

// Guard state
bool   guard_on  = false;
float  cos_lpf   = 1.0f;              // filtered cos(angle) between gravities

// physical forward previously read as −X; flip X so forward ⇒ +X
const int8_t ORIENT_A[9] = {
  -1, 0, 0,
   0,+1, 0,
   0, 0,+1
};
const int8_t ORIENT_B[9] = {
  -1, 0, 0,
   0,+1, 0,
   0, 0,+1
};

// widen quiet window so a slightly-tilted board isn't considered "dynamic"
const float G_NOMINAL = 9.80665f;
const float G_LOW  = 8.8f;
const float G_HIGH = 11.5f;

// stillness auto-reseed (plumbing kept in case you want it later)
bool wantReseedA = false, wantReseedB = false;

int score = 0;

const uint8_t TEMP_LED1 = 9;   // shows "01" (A)
const uint8_t TEMP_LED2 = 10;  // shows "10" (B)

inline void setTempLEDs(bool l9, bool l10) {
  digitalWrite(TEMP_LED1, l9 ? HIGH : LOW);
  digitalWrite(TEMP_LED2, l10 ? HIGH : LOW);
}

// Demo sequence state
bool demo_active = false;
unsigned long demo_t0 = 0;

inline void setTargetLEDs(DemoTarget t) {
  switch (t) {
    case TGT_A:  setTempLEDs(true,  false); break; // "01"
    case TGT_B:  setTempLEDs(false, true ); break; // "10"
    case TGT_PB: setTempLEDs(true,  true ); break; // "11"
  }
}

DemoPhase demo_phase = DEMO_IDLE;
DemoTarget target = TGT_A;
const unsigned long DEMO_ON_MS    = 10000UL; // max window for an ON phase
const unsigned long DEMO_BREAK_MS = 2000UL; // break time now 2 seconds

// rounds / fails
uint16_t rounds = 0;
const uint16_t MAX_ROUNDS = 103;
uint8_t fails = 0;
const uint8_t MAX_FAILS = 3;

bool game_over = false;
const uint16_t GAMEOVER_BLINK_MS = 250;  // blink period


volatile uint8_t disp_left  = 0;
volatile uint8_t disp_right = 0;

unsigned long phase_t0 = 0;
bool phase_met = false;         // was the required action seen during ON?

// edge detectors (so we count "at least once")
bool prevPunchA = false;
bool prevPunchB = false;
bool prevGuard  = false;

// --- PASS/FAIL 1s pulse state ---
bool pass_pulse = false, fail_pulse = false;
unsigned long pass_until = 0, fail_until = 0;

// fire-and-forget helpers
inline void triggerPass() {
  pass_pulse = true;
  pass_until = millis() + 1000UL;  // 1 second
  digitalWrite(LED_PASS, HIGH);
}
inline void triggerFail() {
  fail_pulse = true;
  fail_until = millis() + 1000UL;  // 1 second
  digitalWrite(LED_FAIL, HIGH);
}


ISR(TIMER2_COMPA_vect) {
  // Alternate which digit is shown each interrupt
  static bool showLeft = false;
  showLeft = !showLeft;

  // Blank both
  digitalWrite(EN_A, LOW);
  digitalWrite(EN_B, LOW);

  // Push BCD for the digit we’re about to enable
  uint8_t val = showLeft ? disp_left : disp_right;
  for (int i = 0; i < 4; ++i) digitalWrite(BCD_PINS[i], (val >> i) & 1);

  // Enable the selected digit (BI/ HIGH = show)
  if (showLeft) digitalWrite(EN_B, HIGH);
  else          digitalWrite(EN_A, HIGH);
}



// ----- HELPERS -----
static inline float mag3(float x, float y, float z) {
  return sqrtf(x*x + y*y + z*z);
}

// renormalize g to 1g
static inline void renormG(GravState &st) {
  float gm = mag3(st.gx, st.gy, st.gz);
  if (gm > 1e-3f) {
    float s = G_NOMINAL / gm;
    st.gx *= s; st.gy *= s; st.gz *= s;
  }
}

void writeBCD(uint8_t val) {
  val &= 0x0F;
  for (int i = 0; i < 4; ++i) digitalWrite(BCD_PINS[i], (val >> i) & 1);
}

void showDigitAB(uint8_t leftVal, uint8_t rightVal, bool showLeft) {
  digitalWrite(EN_A, LOW);
  digitalWrite(EN_B, LOW);
  if (showLeft) { writeBCD(leftVal);  digitalWrite(EN_A, HIGH); }
  else          { writeBCD(rightVal); digitalWrite(EN_B, HIGH); }
}

// Map raw MPU frame -> shared body frame using a 3×3 with entries in {-1,0,1}
static inline void mapAccel(const sensors_event_t &a, const int8_t M[9],
                            float &ax, float &ay, float &az) {
  const float rx = a.acceleration.x;
  const float ry = a.acceleration.y;
  const float rz = a.acceleration.z;
  ax = M[0]*rx + M[1]*ry + M[2]*rz;
  ay = M[3]*rx + M[4]*ry + M[5]*rz;
  az = M[6]*rx + M[7]*ry + M[8]*rz;
}

bool i2cReadReg8(uint8_t addr, uint8_t reg, uint8_t &val) {
  Wire.beginTransmission(addr);
  Wire.write(reg);
  uint8_t tx = Wire.endTransmission(false); // repeated start
  if (tx != 0) return false;

  uint32_t t0 = micros();
  uint8_t n = Wire.requestFrom((int)addr, 1, (int)true);
  while (Wire.available() < 1) {           // simple timeout loop
    if ((micros() - t0) > 25000) return false; // 25 ms
  }
  val = Wire.read();
  return (n == 1);
}

void checkHealth(uint8_t addr, HealthState &hs, const char *tag) {
  uint8_t v = 0x00;
  bool ok = i2cReadReg8(addr, WHO_AM_I_REG, v) && (v == WHO_AM_I_VALUE);
  if (!ok) {
    if (hs.failCount < 255) hs.failCount++;
    if (hs.failCount >= HEALTH_FAIL_LIMIT && hs.healthy) {
      hs.healthy = false;
      Serial.print(tag); Serial.println(" unhealthy (WHO_AM_I failed)");
    }
  } else {
    if (!hs.healthy) { Serial.print(tag); Serial.println(" recovered"); }
    hs.healthy = true;
    hs.failCount = 0;
  }
}

bool beginMPU(Adafruit_MPU6050 &mpu, uint8_t addr, const char *tag) {
  if (!mpu.begin(addr)) {
    Serial.print(tag); Serial.println(" begin() failed");
    return false;
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  return true;
}

// ---- LED helpers ----
// void setFwdLED(bool isA, bool on) {
//   if (isA) digitalWrite(LED_A_FWD, on ? HIGH : LOW);
//   else     digitalWrite(LED_B_FWD, on ? HIGH : LOW);
// }
// void clearFwdLEDs(bool isA) { if (isA) digitalWrite(LED_A_FWD, LOW); else digitalWrite(LED_B_FWD, LOW); }

// --- averaged gravity seed to avoid seeding during micro-motion ---
void seedGravity(Adafruit_MPU6050 &mpu, GravState &st, const char *tag, const int8_t ORIENT[9]) {
  sensors_event_t a, g, temp;
  const int N = 50;
  float sx = 0, sy = 0, sz = 0;

  unsigned long t0 = millis();
  int n = 0;
  while (n < N) {
    if (millis() - t0 > 200) break;      // timeout ~200 ms total
    if (!mpu.getEvent(&a, &g, &temp)) continue; // skip if read failed
    float ax, ay, az; mapAccel(a, ORIENT, ax, ay, az);
    sx += ax; sy += ay; sz += az;
    n++;
    delay(2);
  }
  if (n == 0) { // fallback seed
    st.gx = 0; st.gy = 0; st.gz = G_NOMINAL;
  } else {
    st.gx = sx / n; st.gy = sy / n; st.gz = sz / n;
  }
  st.vx = st.px = 0.0f;
  st.vx_pb = 0.0f; st.pbx = 0.0f;
  st.tLast = millis();
  st.g_init = true;
  Serial.print(tag); Serial.print(" gravity/kinematics seeded (avg n="); Serial.print(n); Serial.println(")");
}

inline void displaySet(uint8_t left, uint8_t right) {
  disp_left  = left  % 10;
  disp_right = right % 10;
}

void resetGameAndSeed() {
  
  score = 0;
  rounds = 0;
  fails  = 0;
  game_over = false;

  // 3-2-1-0 countdown, keep multiplexing alive while we wait ~1s per digit
  for (int d = 3; d >= 0; --d) {
    unsigned long end = millis() + 1000;
    while ((long)(millis() - end) < 0) {
      // drive 7-seg as you already do
      displaySet(d, d);
      // tiny idle to avoid WDT-ish tight loop; keep it short to preserve mux
      delay(1);
    }
  }

  // Clear LEDs & guard/reverse-punch state
  // clearFwdLEDs(true); clearFwdLEDs(false);
  // digitalWrite(LED_PULL_BACK, LOW);
  guard_on = false;
  backA_on = backB_on = false;
  tBackA = tBackB = 0;

  // Reseed gravity / kinematics for any healthy sensor
  if (hA.healthy) seedGravity(mpuA, sA, "A (restart)", ORIENT_A);
  if (hB.healthy) seedGravity(mpuB, sB, "B (restart)", ORIENT_B);

  game_started = true;                // now live

  // Start the guided demo phases
  // Start randomized rounds
  target = (DemoTarget)random(0, 3);   // A, B, or PB
  demo_phase = DEMO_ON;
  phase_t0   = millis();
  prevPunchA = prevPunchB = prevGuard = false;
  setTargetLEDs(target);
  prevPunchA = prevPunchB = prevGuard = false; 
}

// ACTIVE-HIGH LED: HIGH = ON, LOW = OFF
void guard(const GravState &sa, const GravState &sb,
           const HealthState &ha, const HealthState &hb,
           unsigned long now) {
  // OFF if either sensor is unhealthy
  if (!(ha.healthy && hb.healthy)) {
    guard_on = false;
    // digitalWrite(LED_PULL_BACK, LOW);
    return;
  }

  // --- per-sensor reverse-punch (backward accel) state ---
  static bool a_on = false, b_on = false;
  static unsigned long ta = 0, tb = 0;

  auto updateBack = [&](const GravState& s, bool &on, unsigned long &t){
    if (!on) {
      if (s.lx_last <= BACK_ON_MS2) { on = true; t = now; }
      return;
    }
    if ((now - t) >= BACK_HOLD_MS && s.lx_last >= BACK_OFF_MS2) {
      on = false;
    }
  };

  updateBack(sa, backA_on, tBackA);
  updateBack(sb, backB_on, tBackB);

  bool bothBack = backA_on && backB_on;

  if (USE_GUARD_POSE) {
    // Build mirrored gravity vectors (mirror B's Y)
    float axg = sa.gx, ayg = sa.gy, azg = sa.gz;
    float bxg = sb.gx, byg = -sb.gy, bzg = sb.gz;

    auto vmag = [](float x,float y,float z){ return sqrtf(x*x+y*y+z*z); };
    float ma = vmag(axg,ayg,azg); if (ma < 1e-3f) ma = 1.0f;
    float mb = vmag(bxg,byg,bzg); if (mb < 1e-3f) mb = 1.0f;
    axg/=ma; ayg/=ma; azg/=ma;  bxg/=mb; byg/=mb; bzg/=mb;

    float cosang = axg*bxg + ayg*byg + azg*bzg;
    cos_lpf = GUARD_COS_ALPHA * cos_lpf + (1.0f - GUARD_COS_ALPHA) * cosang;

    if (!guard_on)  guard_on = (bothBack && (cos_lpf >= GUARD_COS_ON));
    else            guard_on = (bothBack && (cos_lpf >= GUARD_COS_OFF));
  } else {
    guard_on = bothBack;
  }

  // digitalWrite(LED_PULL_BACK, guard_on ? HIGH : LOW);
}

// ------- 1D kinematics helpers (decay factors per dt) -------
static inline float decayFactor(float dt_s, float tau_s) {
  if (tau_s <= 0.0f) return 0.0f;
  if (dt_s < 0.0f) dt_s = 0.0f;
  if (dt_s > 5.0f) dt_s = 5.0f;
  return expf(-dt_s / tau_s);
}

// Process one sensor when healthy
void punch(Adafruit_MPU6050 &mpu, GravState &st, HealthState &hs, bool isA, const int8_t ORIENT[9]) {
  extern bool game_started;
  if (!game_started) return;
  if (!hs.healthy) return; // skip processing if unhealthy
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  // Map raw accel to common body frame
  float ax, ay, az; mapAccel(a, ORIENT, ax, ay, az);

  unsigned long now = millis();
  if (!st.g_init) {
    st.gx = ax; st.gy = ay; st.gz = az;
    st.vx = 0.0f; st.px = 0.0f;
    st.vx_pb = 0.0f; st.pbx = 0.0f;      // >>> pull-back init
    st.tLast = now; st.g_init = true;
  }

  // dt (seconds), clamped
  float dt = (now - st.tLast) * 0.001f; if (dt > DT_MAX_S) dt = DT_MAX_S; st.tLast = now;

  // dynamic test using *raw* accel magnitude
  float amag_raw = mag3(ax, ay, az);
  bool dynamic = (amag_raw < G_LOW) || (amag_raw > G_HIGH);

  // LPF update (freeze only if clearly dynamic)
  if (!dynamic) {
    st.gx = alpha * st.gx + (1.0f - alpha) * ax;
    st.gy = alpha * st.gy + (1.0f - alpha) * ay;
    st.gz = alpha * st.gz + (1.0f - alpha) * az;
    renormG(st);
  }

  // Linear acceleration (m/s^2) in body frame
  float lx = ax - st.gx;
  st.lx_last = lx;

  // --- forward kinematics with decay to limit drift ---
  float kv    = decayFactor(dt, TAU_VEL_S);     // punch velocity leak
  float kp    = decayFactor(dt, TAU_POS_S);     // punch position leak
  float kv_pb = decayFactor(dt, TAU_VEL_PB_S);  // pull-back velocity leak (longer)
  float kp_pb = decayFactor(dt, TAU_POS_PB_S);  // pull-back position leak (longer)

  // velocity (punch path)
  st.vx = st.vx * kv + lx * dt;
  if (st.vx >  VEL_CLAMP) st.vx =  VEL_CLAMP;
  if (st.vx < -VEL_CLAMP) st.vx = -VEL_CLAMP;

  // position (for punch)
  st.px = st.px * kp + st.vx * dt;
  if (st.px >  POS_CLAMP) st.px =  POS_CLAMP;
  if (st.px < -POS_CLAMP) st.px = -POS_CLAMP;

  // >>> pull-back velocity (separate, longer memory)
  const float LX_NOISE = 0.03f; // m/s^2 ~3 mg
  float lx_for_pb = (fabsf(lx) < LX_NOISE) ? 0.0f : lx;

  st.vx_pb = st.vx_pb * kv_pb + lx_for_pb * dt;
  if (st.vx_pb >  VEL_CLAMP) st.vx_pb =  VEL_CLAMP;
  if (st.vx_pb < -VEL_CLAMP) st.vx_pb = -VEL_CLAMP;

  // >>> pull-back position (integrate its own velocity)
  st.pbx = st.pbx * kp_pb + st.vx_pb * dt;

  // if going forward, bleed pbx a bit faster so it releases promptly
  if (lx > 0.0f) st.pbx *= kp_pb;

  if (st.pbx >  POS_CLAMP) st.pbx =  POS_CLAMP;
  if (st.pbx < -POS_CLAMP) st.pbx = -POS_CLAMP;

  // --- Trigger logic: require consistent forward motion (punch) ---
  const bool forwardAccel = (lx > THRESH_X_ON_MS2);
  const bool forwardVel   = (st.vx > 0.05f);
  const bool forwardPos   = (st.px > POS_ON_M);

  // Extra: if we see backward accel, aggressively bleed punch integrators
  if (lx < 0.0f) {
    st.vx *= 0.5f * kv;
    st.px *= 0.7f * kp;
  }

  if (!st.punch_on && forwardAccel && forwardVel && forwardPos) {
    st.punch_on = true; st.tPunch = now;
  } else if (st.punch_on &&
             (now - st.tPunch > HOLD_MS) &&
             ((lx < THRESH_X_OFF_MS2) || (st.px < POS_OFF_M))) {
    st.punch_on = false;
    st.vx *= 0.2f; st.px *= 0.5f;
  } else if (!st.punch_on) {
    st.vx *= kv; st.px *= kp;
  }

  // // Drive LED (solid while active)
  // if (st.punch_on) {
  //   setFwdLED(isA, true);
  // }
  // else{
  //   clearFwdLEDs(isA);
  // }            
}

void setup() {
  Serial.begin(115200);
  Wire.begin();
  Wire.setClock(400000);
  Wire.setWireTimeout(25000, true);

  pinMode(LED_PASS, OUTPUT);
  pinMode(LED_FAIL, OUTPUT);
  // pinMode(LED_PULL_BACK, OUTPUT);
  pinMode(TEMP_LED1, OUTPUT);
  pinMode(TEMP_LED2, OUTPUT);
  setTempLEDs(false, false);
  digitalWrite(LED_PASS, LOW);
  digitalWrite(LED_FAIL, LOW);

  // clearFwdLEDs(true); clearFwdLEDs(false);

  for (int i = 0; i < 4; ++i) pinMode(BCD_PINS[i], OUTPUT);
  pinMode(EN_A, OUTPUT);
  pinMode(EN_B, OUTPUT);

  pinMode(BTN_START, INPUT_PULLUP);     // <<< NEW

  // --- Timer2: CTC, 1 kHz refresh ---
  cli();                 // disable interrupts while we set up
  TCCR2A = 0;
  TCCR2B = 0;
  TCCR2A |= (1 << WGM21);     // CTC mode
  TCCR2B |= (1 << CS22);      // prescaler 64
  OCR2A = 249;                // 16MHz / (64*(249+1)) = 1000 Hz
  TIMSK2 |= (1 << OCIE2A);    // enable compare match A interrupt
  sei();                 // enable interrupts

  game_started = false;                 // ensure idle at boot
  randomSeed(analogRead(A0));  // simple entropy source

  bool okA = beginMPU(mpuA, ADDR_A, "MPU A");
  bool okB = beginMPU(mpuB, ADDR_B, "MPU B");

  hA.healthy = okA; hB.healthy = okB;
  hA.failCount = okA ? 0 : HEALTH_FAIL_LIMIT;
  hB.failCount = okB ? 0 : HEALTH_FAIL_LIMIT;

  // NOTE: do NOT seed here anymore — we seed on Start button
  // if (hA.healthy) seedGravity(...);
  // if (hB.healthy) seedGravity(...);

  Serial.println("Press START to begin (3-2-1-0 then seed).");
  delay(100);
}


void loop() {
  // Handle start/restart button at any time
  if (startPressed()) {
    game_started = false;               // optional: ensure off during countdown
    resetGameAndSeed();
  }

  unsigned long now = millis();

  // --- 7-seg always shows score (or 00 before start) ---
  if (!game_started) {
    displaySet(0, 0);
  } else {
    uint8_t tens = (score / 10) % 10;
    uint8_t ones = score % 10;
    displaySet(tens, ones);
  }



  // Health checks can always run
  if (now - hA.lastCheck >= HEALTH_PERIOD_MS) { hA.lastCheck = now; checkHealth(ADDR_A, hA, "MPU A"); }
  if (now - hB.lastCheck >= HEALTH_PERIOD_MS) { hB.lastCheck = now; checkHealth(ADDR_B, hB, "MPU B"); }

  // end pulses when time is up
  if (pass_pulse && (long)(now - pass_until) >= 0) {
    pass_pulse = false;
    digitalWrite(LED_PASS, LOW);
  }
  if (fail_pulse && (long)(now - fail_until) >= 0) {
    fail_pulse = false;
    digitalWrite(LED_FAIL, LOW);
  }

  // If no active pulse, fall back to health blink status
  if (!pass_pulse) {
    bool aFailBlink = (!hA.healthy) && ((now / FAIL_BLINK_MS) % 2);
    digitalWrite(LED_PASS, aFailBlink ? HIGH : LOW);
  }
  if (!fail_pulse) {
    bool bFailBlink = (!hB.healthy) && ((now / FAIL_BLINK_MS) % 2);
    digitalWrite(LED_FAIL, bFailBlink ? HIGH : LOW);
  }

  // If not started, force LEDs off and DON'T update kinematics
  if (!game_started) {
    // clearFwdLEDs(true); clearFwdLEDs(false);
    // digitalWrite(LED_PULL_BACK, LOW);
    // keep states inert until start
    sA.g_init = sB.g_init = false;     // prevent auto-seed in punch()
    return;
  }

  // ---- Live game path (only runs after Start) ----
  if (wantReseedA && hA.healthy) { wantReseedA = false; seedGravity(mpuA, sA, "A (auto-reseed)", ORIENT_A); }
  if (wantReseedB && hB.healthy) { wantReseedB = false; seedGravity(mpuB, sB, "B (auto-reseed)", ORIENT_B); }

  punch(mpuA, sA, hA, true,  ORIENT_A);
  punch(mpuB, sB, hB, false, ORIENT_B);
  guard(sA, sB, hA, hB, now);

  // --- Guided demo: check required actions and advance phases ---
  if (demo_phase != DEMO_IDLE) {   // <-- was: != DEMO_IDLE && != DEMO_DONE
    unsigned long nowMs = millis();
    unsigned long elapsed = nowMs - phase_t0;

    // detect edges (set true only when it turns on)
    bool punchA_edge = (sA.punch_on && !prevPunchA);
    bool punchB_edge = (sB.punch_on && !prevPunchB);
    bool guard_edge  = (guard_on     && !prevGuard);

    prevPunchA = sA.punch_on;
    prevPunchB = sB.punch_on;
    prevGuard  = guard_on;

    switch (demo_phase) {
      case DEMO_ON: {
        // compute elapsed for this ON window
        if (elapsed > DEMO_ON_MS) {
          // timeout = fail, count round, go to BREAK/DONE
          triggerFail();
          fails++;
          rounds++;
          setTempLEDs(false, false);
          bool hitFailLimit  = (fails  >= MAX_FAILS);
          bool hitRoundLimit = (rounds >= MAX_ROUNDS);
          demo_phase = (hitFailLimit || hitRoundLimit) ? DEMO_DONE : DEMO_BREAK;
          game_over  = hitFailLimit;   // only true if we ended due to fails
          phase_t0   = nowMs;
          break;
        }

        // EARLY EXIT on first correct/wrong action depending on target
        bool correct = false, wrong = false;
        if (target == TGT_A) {
          if (punchA_edge) correct = true;
          else if (punchB_edge || guard_edge) wrong = true;
        } else if (target == TGT_B) {
          if (punchB_edge) correct = true;
          else if (punchA_edge || guard_edge) wrong = true;
        } else { // TGT_PB
          if (guard_edge) correct = true;
          else if (punchA_edge || punchB_edge) wrong = true;
        }

        if (correct) {
          score++;
          triggerPass();
          rounds++;
          setTempLEDs(false, false);
          bool hitRoundLimit = (rounds >= MAX_ROUNDS);
          demo_phase = hitRoundLimit ? DEMO_DONE : DEMO_BREAK;
          game_over  = false;   // ending because rounds finished is NOT game over
          phase_t0   = nowMs;
          break;
        }
        if (wrong) {
          triggerFail();
          fails++;
          rounds++;
          setTempLEDs(false, false);
          bool hitFailLimit  = (fails  >= MAX_FAILS);
          bool hitRoundLimit = (rounds >= MAX_ROUNDS);
          demo_phase = (hitFailLimit || hitRoundLimit) ? DEMO_DONE : DEMO_BREAK;
          game_over  = hitFailLimit;
          phase_t0   = nowMs;
          break;
        }
      } break;

      case DEMO_BREAK:
        if (elapsed >= DEMO_BREAK_MS) {
          // pick a new random target and start next round
          target = (DemoTarget)random(0, 3);
          setTargetLEDs(target);
          demo_phase = DEMO_ON;
          phase_t0 = nowMs;
          // reset edge trackers so we don't count stale highs
          prevPunchA = prevPunchB = prevGuard = false;
        }
        break;

      case DEMO_DONE: {
        if (game_over) {
          // continuous blink on both LEDs 9 & 10
          bool on = ((nowMs / GAMEOVER_BLINK_MS) % 2);
          setTempLEDs(on, on);
        } else {
          // finished the 103 rounds without hitting fail limit: stay off
          setTempLEDs(false, false);
        }
      } break;

      default: break;
    }
  }

}
