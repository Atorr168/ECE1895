// Dual MPU6050 with X-axis trigger + health monitoring (identify which MPU fails)
// Now also requires forward DISPLACEMENT relative to initial pose, not just accel.
// FIXES:
//  - Proper per-sensor 3×3 orientation mapping (no ad-hoc X flip)
//  - Averaged gravity seed
//  - Freeze gravity LPF during high dynamics so it won't "learn" the shove
//  - Separate kinematics for punch vs. pull-back (longer memory for pull-back)

#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <math.h>


// ==== 1) Types FIRST (before any function that uses them) ====
struct GravState {
  bool g_init = false;
  float gx = 0, gy = 0, gz = 0;
  float vx = 0, px = 0;
  float vx_pb = 0, pbx = 0;
  unsigned long tLast = 0;
  bool punch_on = false;
  unsigned long tPunch = 0;
  float lx_last = 0.0f;
  // NEW:
  unsigned long rev_rearm_until = 0;
  float px_last = 0.0f;

  bool   arming = false;
  unsigned long tArm = 0;
  float  px_at_arm = 0.0f;
};


struct HealthState {
  bool healthy = true;
  uint8_t failCount = 0;
  unsigned long lastCheck = 0;
};
 
// --- Demo phases ---
enum DemoPhase : uint8_t { DEMO_IDLE = 0, DEMO_ON, DEMO_BREAK, DEMO_DONE };
enum DemoTarget : uint8_t { TGT_A = 0, TGT_B = 1, TGT_PB = 2 };

// ==== 2) Globals that use those types ====
bool game_started = false;
GravState sA, sB;
HealthState hA, hB;


// ----- I2C ADDRESSES -----
const uint8_t ADDR_A = 0x68;   // AD0=GND
const uint8_t ADDR_B = 0x69;   // AD0=VCC

// ----- SENSORS -----
Adafruit_MPU6050 mpuA;
Adafruit_MPU6050 mpuB;

// ----- CONFIG -----
float alpha = 0.98f; // gravity LPF factor
const uint16_t HOLD_MS = 150;    // LED hold after trigger (ms)

// X-axis thresholds (m/s^2)
const float THRESH_X_ON_MS2  = 5.5f;   // was 7.5
const float THRESH_X_OFF_MS2 = 1.2f;   // keep

// Punch displacement gates (meters, forward = +X)
const float POS_ON_M  = 0.015f;        // was 0.020
const float POS_OFF_M = 0.012f;        // keep

// Absolute forward displacement (from seed) required for a punch
const float ABS_POS_ON_M  = 0.08f;  // 8 cm to trigger
const float ABS_POS_OFF_M = 0.05f;  // 5 cm to release (hysteresis)

// NEW pull-back displacement gates (meters, backward = −X)
const float PB_POS_ON_M  = 0.020f;   // 2.0 cm to trigger guard
const float PB_POS_OFF_M = 0.012f;   // 1.2 cm to release (hysteresis)

// Add near the top with other config:
const uint16_t GUARD_REARM_MS = 120;   // refractory after guard releases
unsigned long guard_rearm_until = 0;

// Integration drift control (time constants, seconds)
const float TAU_VEL_S = 0.25f;  // velocity leak [punch]
const float TAU_POS_S = 2.0f;   // position leak [punch]

// >>> pull-back: longer memory so slow moves accumulate
const float TAU_VEL_PB_S = 1.0f; // pull-back velocity leak
const float TAU_POS_PB_S = 4.0f; // pull-back position leak

// dt clamp for robustness (~20 Hz)
const float DT_MAX_S  = 0.05f;

// Optional hard clamps to keep integrator bounded
const float VEL_CLAMP = 10.0f;  // m/s
const float POS_CLAMP = 0.30f;  // m   (30 cm envelope)

// --- Start button ---
const uint8_t BTN_START   = 13;     // tie to GND when pressed
const uint16_t DEBOUNCE_MS = 30;

bool btnPrev = true;                // INPUT_PULLUP: true = released
unsigned long lastBtnChange = 0;

inline bool startPressed() {
  bool s = (digitalRead(BTN_START) == LOW);
  if (s != btnPrev && (millis() - lastBtnChange) > DEBOUNCE_MS) {
    btnPrev = s; lastBtnChange = millis();
    if (s) return true;             // rising edge (press)
  }
  return false;
}

// const uint8_t LED_PULL_BACK = 5;
const uint8_t LED_PASS = 6;     // temp led for pass fail, and MPU A init
const uint8_t LED_FAIL = 7;     // temp led for pass fail, and MPU B init

// BCD bus (share to both 7447s)
const uint8_t BCD_PINS[4] = {2, 3, 4, 5}; // A,B,C,D (choose any free pins)

// Per-digit enables to 7447 BI/ pins (active LOW to blank)
const uint8_t EN_A = 12;  // -> BI/_A
const uint8_t EN_B = 11;  // -> BI/_B

// Health monitor
const uint8_t WHO_AM_I_REG   = 0x75;
const uint8_t WHO_AM_I_VALUE = 0x68;  // expected for MPU6050
const uint8_t HEALTH_FAIL_LIMIT = 3;
const uint16_t HEALTH_PERIOD_MS = 500;
const uint16_t FAIL_BLINK_MS = 100;

// --- Guard-pose option (Y/Z agreement). Leave OFF to use reverse-accel-only ---
const bool USE_GUARD_POSE = false;   // <- set true to re-enable Y/Z checks

// Guard-pose gating (angle + hysteresis + smoothing) — very loose cone
const float GUARD_COS_ON  = 0.35f;
const float GUARD_COS_OFF = 0.25f;
const float GUARD_COS_ALPHA = 0.80f;  // LPF on cos(angle)

// Optional: bleed a tad slower so PB state sticks long enough to latch
// was 0.75
const float GUARD_PB_BLEED = 0.80f;   // 0.75→0.80: slower decay while guard_on

// Add to globals:
const uint16_t GUARD_MAX_HOLD_MS = 700; // tune 600–900 ms
static unsigned long tGuardOn = 0;

bool backA_on = false, backB_on = false;
unsigned long tBackA = 0, tBackB = 0;

// Reverse/back accel thresholds — slightly easier to hit
// was -3.5 / -1.5
const float BACK_ON_MS2  = -2.8f;    // classify "back" sooner
const float BACK_OFF_MS2 = -1.2f;    // release a touch sooner

// Overlap/hold for A & B agreement
// was 120 ms hold, 80 ms overlap
const uint16_t BACK_HOLD_MS    = 90;  // less time "both back" needed to latch
const uint16_t BACK_OVERLAP_MS = 100; // a bit more A/B skew allowed

// --- classify back using accel + displacement, but veto any forward motion
const float BACK_ACCEL_VETO = 0.25f;   // small positive accel = not back
const float BACK_MOVE_EPS   = 0.01f;   // tiny backward speed threshold

// Reverse -> temporarily block punch arming (tighten thresholds a bit)
const uint16_t REVERSE_REARM_MS    = 120;   // 100–150 ms is fine
const float    REVERSE_ACCEL_TRIP  = -2.0f; // require clearer backward accel
const float    PB_VEL_TRIP         = -0.08f;// require a bit more back drift

// Adaptive growth thresholds (abs and rate-based)
const float    POS_GROWTH_MIN_ABS  = 0.0008f; // ~0.8 mm absolute per loop
const float    POS_GROWTH_MIN_RATE = 0.02f;   // ~2 cm/s equivalent

// Extra safety: require px to be growing a hair while arming
const float    POS_GROWTH_MIN     = 0.003f; // ~3 mm since last loop

// --- Tiny arming window so we measure real growth over ~80–140 ms ---
const uint16_t ARM_WIN_MS      = 150;     // was 120
const float    ARM_GROWTH_NEED = 0.0035f; // was 0.006 (need ~3.5 mm)

// Guard state
bool   guard_on  = false;
float  cos_lpf   = 1.0f;              // filtered cos(angle) between gravities

// physical forward previously read as −X; flip X so forward ⇒ +X
const int8_t ORIENT_A[9] = {
  -1, 0, 0,
   0,+1, 0,
   0, 0,+1
};
const int8_t ORIENT_B[9] = {
  -1, 0, 0,
   0,+1, 0,
   0, 0,+1
};

// widen quiet window so a slightly-tilted board isn't considered "dynamic"
const float G_NOMINAL = 9.80665f;
const float G_LOW  = 8.8f;
const float G_HIGH = 11.5f;

// stillness auto-reseed (plumbing kept in case you want it later)
bool wantReseedA = false, wantReseedB = false;

int score = 0;

const uint8_t TEMP_LED1 = 0;   // shows "01" (A)
const uint8_t TEMP_LED2 = 1;  // shows "10" (B)

inline void setTempLEDs(bool left, bool right) {
  digitalWrite(TEMP_LED1, left ? HIGH : LOW);
  digitalWrite(TEMP_LED2, right ? HIGH : LOW);
}

// Demo sequence state
bool demo_active = false;
unsigned long demo_t0 = 0;

inline void setTargetLEDs(DemoTarget t) {
  switch (t) {
    case TGT_A:  setTempLEDs(true,  false); break; // "01"
    case TGT_B:  setTempLEDs(false, true ); break; // "10"
    case TGT_PB: setTempLEDs(true,  true ); break; // "11"
  }
}

DemoPhase demo_phase = DEMO_IDLE;
DemoTarget target = TGT_A;
const unsigned long DEMO_ON_MS    = 10000UL; // max window for an ON phase
const unsigned long DEMO_BREAK_MS = 2000UL; // break time now 2 seconds

// rounds / fails
uint16_t rounds = 0;
const uint16_t MAX_ROUNDS = 103;
uint8_t fails = 0;
const uint8_t MAX_FAILS = 3;

bool game_over = false;
const uint16_t GAMEOVER_BLINK_MS = 250;  // blink period


volatile uint8_t disp_left  = 0;
volatile uint8_t disp_right = 0;

unsigned long phase_t0 = 0;
bool phase_met = false;         // was the required action seen during ON?

// edge detectors (so we count "at least once")
bool prevPunchA = false;
bool prevPunchB = false;
bool prevGuard  = false;

// --- PASS/FAIL 1s pulse state ---
bool pass_pulse = false, fail_pulse = false;
unsigned long pass_until = 0, fail_until = 0;

// fire-and-forget helpers
inline void triggerPass() {
  pass_pulse = true;
  pass_until = millis() + 1000UL;  // 1 second
  digitalWrite(LED_PASS, HIGH);
}
inline void triggerFail() {
  fail_pulse = true;
  fail_until = millis() + 1000UL;  // 1 second
  digitalWrite(LED_FAIL, HIGH);
}

static inline void quieten(GravState &st) {
  st.punch_on = false;
  st.arming   = false;
  st.vx      *= 0.25f;   // strong bleed
  st.px      *= 0.50f;
  st.vx_pb   *= 0.50f;
  st.pbx     *= 0.50f;
}



ISR(TIMER2_COMPA_vect) {
  // Alternate which digit is shown each interrupt
  static bool showLeft = false;
  showLeft = !showLeft;

  // Blank both
  digitalWrite(EN_A, LOW);
  digitalWrite(EN_B, LOW);

  // Push BCD for the digit we’re about to enable
  uint8_t val = showLeft ? disp_left : disp_right;
  for (int i = 0; i < 4; ++i) digitalWrite(BCD_PINS[i], (val >> i) & 1);

  // Enable the selected digit (BI/ HIGH = show)
  if (showLeft) digitalWrite(EN_B, HIGH);
  else          digitalWrite(EN_A, HIGH);
}



// ----- HELPERS -----
static inline float mag3(float x, float y, float z) {
  return sqrtf(x*x + y*y + z*z);
}

// renormalize g to 1g
static inline void renormG(GravState &st) {
  float gm = mag3(st.gx, st.gy, st.gz);
  if (gm > 1e-3f) {
    float s = G_NOMINAL / gm;
    st.gx *= s; st.gy *= s; st.gz *= s;
  }
}

void writeBCD(uint8_t val) {
  val &= 0x0F;
  for (int i = 0; i < 4; ++i) digitalWrite(BCD_PINS[i], (val >> i) & 1);
}

void showDigitAB(uint8_t leftVal, uint8_t rightVal, bool showLeft) {
  digitalWrite(EN_A, LOW);
  digitalWrite(EN_B, LOW);
  if (showLeft) { writeBCD(leftVal);  digitalWrite(EN_A, HIGH); }
  else          { writeBCD(rightVal); digitalWrite(EN_B, HIGH); }
}

// Map raw MPU frame -> shared body frame using a 3×3 with entries in {-1,0,1}
static inline void mapAccel(const sensors_event_t &a, const int8_t M[9],
                            float &ax, float &ay, float &az) {
  const float rx = a.acceleration.x;
  const float ry = a.acceleration.y;
  const float rz = a.acceleration.z;
  ax = M[0]*rx + M[1]*ry + M[2]*rz;
  ay = M[3]*rx + M[4]*ry + M[5]*rz;
  az = M[6]*rx + M[7]*ry + M[8]*rz;
}

bool i2cReadReg8(uint8_t addr, uint8_t reg, uint8_t &val) {
  Wire.beginTransmission(addr);
  Wire.write(reg);
  uint8_t tx = Wire.endTransmission(false); // repeated start
  if (tx != 0) return false;

  uint32_t t0 = micros();
  uint8_t n = Wire.requestFrom((int)addr, 1, (int)true);
  while (Wire.available() < 1) {           // simple timeout loop
    if ((micros() - t0) > 25000) return false; // 25 ms
  }
  val = Wire.read();
  return (n == 1);
}

void checkHealth(uint8_t addr, HealthState &hs, const char *tag) {
  uint8_t v = 0x00;
  bool ok = i2cReadReg8(addr, WHO_AM_I_REG, v) && (v == WHO_AM_I_VALUE);
  if (!ok) {
    if (hs.failCount < 255) hs.failCount++;
    if (hs.failCount >= HEALTH_FAIL_LIMIT && hs.healthy) {
      hs.healthy = false;
      // Serial.print(tag); Serial.println(" unhealthy (WHO_AM_I failed)");
    }
  } else {
    // if (!hs.healthy) { Serial.print(tag); Serial.println(" recovered"); }
    hs.healthy = true;
    hs.failCount = 0;
  }
}

bool beginMPU(Adafruit_MPU6050 &mpu, uint8_t addr, const char *tag) {
  if (!mpu.begin(addr)) {
    // Serial.print(tag); Serial.println(" begin() failed");
    return false;
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  return true;
}

// ---- LED helpers ----
// void setFwdLED(bool isA, bool on) {
//   if (isA) digitalWrite(LED_A_FWD, on ? HIGH : LOW);
//   else     digitalWrite(LED_B_FWD, on ? HIGH : LOW);
// }
// void clearFwdLEDs(bool isA) { if (isA) digitalWrite(LED_A_FWD, LOW); else digitalWrite(LED_B_FWD, LOW); }

// --- averaged gravity seed to avoid seeding during micro-motion ---
void seedGravity(Adafruit_MPU6050 &mpu, GravState &st, const char *tag, const int8_t ORIENT[9]) {
  sensors_event_t a, g, temp;
  const int N = 50;
  float sx = 0, sy = 0, sz = 0;
  

  unsigned long t0 = millis();
  int n = 0;
  while (n < N) {
    if (millis() - t0 > 200) break;      // timeout ~200 ms total
    if (!mpu.getEvent(&a, &g, &temp)) continue; // skip if read failed
    float ax, ay, az; mapAccel(a, ORIENT, ax, ay, az);
    sx += ax; sy += ay; sz += az;
    n++;
    delay(2);
  }
  if (n == 0) { // fallback seed
    st.gx = 0; st.gy = 0; st.gz = G_NOMINAL;
  } else {
    st.gx = sx / n; st.gy = sy / n; st.gz = sz / n;
  }
  st.vx = st.px = 0.0f;
  st.vx_pb = 0.0f; st.pbx = 0.0f;
  st.px_last = 0.0f;              
  st.rev_rearm_until = 0;            
  st.arming = false;         
  st.tArm = 0;            
  st.px_at_arm = 0.0f;       

  st.tLast = millis();
  st.g_init = true;
  // Serial.print(tag); Serial.print(" gravity/kinematics seeded (avg n="); Serial.print(n); Serial.println(")");
}

inline void displaySet(uint8_t left, uint8_t right) {
  disp_left  = left  % 10;
  disp_right = right % 10;
}

void resetGameAndSeed() {
  
  score = 0;
  rounds = 0;
  fails  = 0;
  game_over = false;

  // 3-2-1-0 countdown, keep multiplexing alive while we wait ~1s per digit
  for (int d = 3; d >= 0; --d) {
    unsigned long end = millis() + 1000;
    while ((long)(millis() - end) < 0) {
      // drive 7-seg as you already do
      displaySet(d, d);
      // tiny idle to avoid WDT-ish tight loop; keep it short to preserve mux
      delay(1);
    }
  }

  // Clear LEDs & guard/reverse-punch state
  // clearFwdLEDs(true); clearFwdLEDs(false);
  // digitalWrite(LED_PULL_BACK, LOW);
  guard_on = false;
  backA_on = backB_on = false;
  tBackA = tBackB = 0;

  // Reseed gravity / kinematics for any healthy sensor
  if (hA.healthy) seedGravity(mpuA, sA, "A (restart)", ORIENT_A);
  if (hB.healthy) seedGravity(mpuB, sB, "B (restart)", ORIENT_B);

  game_started = true;                // now live

  // Start the guided demo phases
  // Start randomized rounds
  target = (DemoTarget)random(0, 3);   // A, B, or PB
  demo_phase = DEMO_ON;
  phase_t0   = millis();
  prevPunchA = prevPunchB = prevGuard = false;
  setTargetLEDs(target);
  prevPunchA = prevPunchB = prevGuard = false; 
}

// ACTIVE-HIGH LED: HIGH = ON, LOW = OFF
// Change signature so we can modify states:
void guard(GravState &sa, GravState &sb,
           const HealthState &ha, const HealthState &hb,
           unsigned long now) 
{
  if (!(ha.healthy && hb.healthy)) { 
    guard_on = false; 
    return; 
  }

  // Forward-motion veto: any clear forward accel cancels guard.
  bool forwardVeto = (sa.lx_last > BACK_ACCEL_VETO) || (sb.lx_last > BACK_ACCEL_VETO);
  static unsigned long lastBackA = 0, lastBackB = 0;
  static unsigned long tBothStart = 0;

  if (forwardVeto) {
    tBothStart = 0;
    lastBackA = lastBackB = 0;
    if (guard_on) {
      guard_on = false;
      guard_rearm_until = now + GUARD_REARM_MS;
    }
    return;
  }

  // Record "recent backward accel" moments
  if (sa.lx_last <= BACK_ON_MS2) lastBackA = now;
  if (sb.lx_last <= BACK_ON_MS2) lastBackB = now;

  // Are both sides "recently back" (timing tolerance)?
  bool bothBackRecent = ((now - lastBackA) <= BACK_OVERLAP_MS) &&
                        ((now - lastBackB) <= BACK_OVERLAP_MS);

  // Basic displacement condition (behind threshold)
  bool bothBehind = (sa.pbx <= -PB_POS_ON_M) && (sb.pbx <= -PB_POS_ON_M);

  // If not latched, only consider arming once rearm window is over
  if (!guard_on) {
    if ((long)(now - guard_rearm_until) < 0) {
      tBothStart = 0;
      return;
    }

    // Latch when: both had recent backward accel AND both are behind −PB_POS_ON_M,
    // and they hold that state for BACK_HOLD_MS.
    if (bothBackRecent && bothBehind) {
      if (tBothStart == 0) tBothStart = now;
      if ((now - tBothStart) >= BACK_HOLD_MS) {
        guard_on = true;
        tGuardOn = now;

        // Dampen forward integrators a bit on latch
        sa.vx *= 0.2f; sa.px *= 0.3f;
        sb.vx *= 0.2f; sb.px *= 0.3f;
      }
    } else {
      tBothStart = 0;
    }
    return;
  }

  // ---- Latched: bleed PB gently and check release conditions ----
  sa.pbx   *= GUARD_PB_BLEED;
  sb.pbx   *= GUARD_PB_BLEED;
  sa.vx_pb *= GUARD_PB_BLEED;
  sb.vx_pb *= GUARD_PB_BLEED;

  // Release if either side is no longer clearly back in accel OR no longer behind −PB_POS_OFF_M
  bool releaseA = (sa.lx_last >= BACK_OFF_MS2) || (sa.pbx >= -PB_POS_OFF_M);
  bool releaseB = (sb.lx_last >= BACK_OFF_MS2) || (sb.pbx >= -PB_POS_OFF_M);

  bool timeout  = ((now - tGuardOn) >= GUARD_MAX_HOLD_MS);

  if (releaseA || releaseB || timeout) {
    guard_on = false;
    guard_rearm_until = now + GUARD_REARM_MS;
    tBothStart = 0;
  }
}



// ------- 1D kinematics helpers (decay factors per dt) -------
static inline float decayFactor(float dt_s, float tau_s) {
  if (tau_s <= 0.0f) return 0.0f;
  if (dt_s < 0.0f) dt_s = 0.0f;
  if (dt_s > 5.0f) dt_s = 5.0f;
  return expf(-dt_s / tau_s);
}


// Uncomment to enable the sanity LED test (forward/back accel blink)
// 0 = off, 1 = on
#define SANITY_ACCEL_DEBUG 0

void punch(Adafruit_MPU6050 &mpu, GravState &st, HealthState &hs, bool isA, const int8_t ORIENT[9]) {
  extern bool game_started;
  if (!game_started) return;
  if (!hs.healthy)  return;

  if (demo_phase != DEMO_ON) {
  // Keep integrators calm and prevent stale latch from leaking forward.
  quieten(st);
  st.tLast = millis();   // avoid a huge dt burst when ON resumes
  return;
}

  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  // Map raw accel to common body frame
  float ax, ay, az; mapAccel(a, ORIENT, ax, ay, az);

  unsigned long now = millis();
  if (!st.g_init) {
    st.gx = ax; st.gy = ay; st.gz = az;
    st.vx = 0.0f; st.px = 0.0f;
    st.vx_pb = 0.0f; st.pbx = 0.0f;
    st.px_last = 0.0f;
    st.rev_rearm_until = 0;
    st.arming = false;
    st.tArm = 0;
    st.px_at_arm = 0.0f;
    st.tLast = now; st.g_init = true;
  }

  // dt (seconds), clamped
  float dt = (now - st.tLast) * 0.001f;
  if (dt > DT_MAX_S) dt = DT_MAX_S;
  st.tLast = now;

  // Dynamic test using raw accel magnitude
  float amag_raw = mag3(ax, ay, az);
  bool dynamic = (amag_raw < G_LOW) || (amag_raw > G_HIGH);

  // Gravity LPF update (freeze when clearly dynamic)
  if (!dynamic) {
    st.gx = alpha * st.gx + (1.0f - alpha) * ax;
    st.gy = alpha * st.gy + (1.0f - alpha) * ay;
    st.gz = alpha * st.gz + (1.0f - alpha) * az;
    renormG(st);
  }

  // Linear acceleration (m/s^2)
  float lx = ax - st.gx;
  st.lx_last = lx;

  // ----- Optional sanity LEDs (forward/back accel sign) -----
  #if defined(SANITY_ACCEL_DEBUG) && SANITY_ACCEL_DEBUG
    digitalWrite(LED_PASS, (lx >  3.0f) ? HIGH : LOW);  // forward accel
    digitalWrite(LED_FAIL, (lx < -3.0f) ? HIGH : LOW);  // backward accel
  #endif

  // Reverse detection -> temporary lockout and bleed forward state
  if (lx <= 0.0f && (lx < REVERSE_ACCEL_TRIP || st.vx_pb < PB_VEL_TRIP)) {
    st.rev_rearm_until = now + REVERSE_REARM_MS;
    st.vx *= 0.2f;   // stronger bleed so stale forward can't pass gates
    st.px *= 0.6f;
  }

  // Lockouts
  bool inhibitPunch =
      guard_on ||
      ((long)(now - guard_rearm_until) < 0) ||
      ((long)(now - st.rev_rearm_until) < 0);

  // ------- decay factors -------
  float kv    = decayFactor(dt, TAU_VEL_S);
  float kp    = decayFactor(dt, TAU_POS_S);
  float kv_pb = decayFactor(dt, TAU_VEL_PB_S);
  float kp_pb = decayFactor(dt, TAU_POS_PB_S);

  // ====== FORWARD (punch) INTEGRATION ======
  if (lx > 0.0f && !inhibitPunch) {
    st.vx = st.vx * kv + lx * dt;      // integrate forward accel
  } else {
    if (inhibitPunch) {
      st.vx = st.vx * (kv * 0.3f);     // stronger bleed while inhibited
      st.px = st.px * (kp * 0.8f);
    } else {
      st.vx = st.vx * (kv * 0.4f);     // mild bleed otherwise
    }
  }
  st.vx = fmaxf(fminf(st.vx,  VEL_CLAMP), -VEL_CLAMP);

  st.px = st.px * kp + st.vx * dt;     // integrate position
  st.px = fmaxf(fminf(st.px,  POS_CLAMP), -POS_CLAMP);

  // ====== PULL-BACK INTEGRATION (for guard/back logic) ======
  const float LX_NOISE = 0.05f;
  float lx_for_pb = (fabsf(lx) < LX_NOISE) ? 0.0f : lx;
  st.vx_pb = st.vx_pb * kv_pb + lx_for_pb * dt;
  st.vx_pb = fmaxf(fminf(st.vx_pb,  VEL_CLAMP), -VEL_CLAMP);
  st.pbx   = st.pbx   * kp_pb + st.vx_pb * dt;
  if (lx > 0.0f) {                     // bleed PB quickly during forward motion
    st.pbx   *= (kp_pb * 0.6f);
    st.vx_pb *= (kv_pb * 0.6f);
  }
  st.pbx = fmaxf(fminf(st.pbx,  POS_CLAMP), -POS_CLAMP);

  // ====== Arming window & trigger logic ======
  if (!inhibitPunch && lx > 0.0f) {
    if (!st.arming) {
      st.arming    = true;
      st.tArm      = now;
      st.px_at_arm = st.px;
    }
  } else if (inhibitPunch || lx < -0.2f) {
    st.arming = false;
  }

  bool growthOK = false;
  if (st.arming) {
    float grown = st.px - st.px_at_arm;
    if (grown > ARM_GROWTH_NEED) {
      growthOK = true;
    } else if ((now - st.tArm) > ARM_WIN_MS) {
      st.arming = false;               // window expired without enough growth
    }
  }

  // Core gates
  bool forwardAccel = (lx > THRESH_X_ON_MS2);
  bool forwardVel   = (st.vx > 0.015f);

  // Near-term position (small gate) + arming growth
  bool forwardPos   = (st.px > POS_ON_M);
  bool posOK        = forwardPos || (st.arming && (st.px - st.px_at_arm) > ARM_GROWTH_NEED);

  // Absolute forward displacement gate (from seed)
  bool absPosOn  = (st.px >= ABS_POS_ON_M);  // e.g., 0.08 m
  bool absPosOff = (st.px <= ABS_POS_OFF_M); // e.g., 0.05 m

  if (inhibitPunch) {
    forwardAccel = forwardVel = false;
    posOK = false;
    st.arming = false;
  }

  // Trigger + release with absolute gate included
  if (!st.punch_on && forwardAccel && forwardVel && posOK && absPosOn) {
    st.punch_on = true; 
    st.tPunch = now;
  } 
  else if (st.punch_on &&
           (now - st.tPunch > HOLD_MS) &&
           ( (lx < THRESH_X_OFF_MS2) || (st.px < POS_OFF_M) || absPosOff )) {
    st.punch_on = false;
    st.vx *= 0.2f; 
    st.px *= 0.5f;
  }

  // remember for next loop
  st.px_last = st.px;
}




void setup() {
  // Serial.begin(115200);
  Wire.begin();
  Wire.setClock(400000);
  Wire.setWireTimeout(25000, true);

  pinMode(LED_PASS, OUTPUT);
  pinMode(LED_FAIL, OUTPUT);
  // pinMode(LED_PULL_BACK, OUTPUT);
  pinMode(TEMP_LED1, OUTPUT);
  pinMode(TEMP_LED2, OUTPUT);
  setTempLEDs(false, false);
  digitalWrite(LED_PASS, LOW);
  digitalWrite(LED_FAIL, LOW);

  // clearFwdLEDs(true); clearFwdLEDs(false);

  for (int i = 0; i < 4; ++i) pinMode(BCD_PINS[i], OUTPUT);
  pinMode(EN_A, OUTPUT);
  pinMode(EN_B, OUTPUT);

  pinMode(BTN_START, INPUT_PULLUP);     // <<< NEW

  // --- Timer2: CTC, 1 kHz refresh ---
  cli();                 // disable interrupts while we set up
  TCCR2A = 0;
  TCCR2B = 0;
  TCCR2A |= (1 << WGM21);     // CTC mode
  TCCR2B |= (1 << CS22);      // prescaler 64
  OCR2A = 249;                // 16MHz / (64*(249+1)) = 1000 Hz
  TIMSK2 |= (1 << OCIE2A);    // enable compare match A interrupt
  sei();                 // enable interrupts

  game_started = false;                 // ensure idle at boot
  randomSeed(analogRead(A0));  // simple entropy source

  bool okA = beginMPU(mpuA, ADDR_A, "MPU A");
  bool okB = beginMPU(mpuB, ADDR_B, "MPU B");

  hA.healthy = okA; hB.healthy = okB;
  hA.failCount = okA ? 0 : HEALTH_FAIL_LIMIT;
  hB.failCount = okB ? 0 : HEALTH_FAIL_LIMIT;

  // NOTE: do NOT seed here anymore — we seed on Start button
  // if (hA.healthy) seedGravity(...);
  // if (hB.healthy) seedGravity(...);

  // Serial.println("Press START to begin (3-2-1-0 then seed).");
  delay(100);
}


void loop() {
  // Handle start/restart button at any time
  if (startPressed()) {
    game_started = false;               // optional: ensure off during countdown
    resetGameAndSeed();
  }

  unsigned long now = millis();

  // --- 7-seg always shows score (or 00 before start) ---
  if (!game_started) {
    displaySet(0, 0);
  } else {
    uint8_t tens = (score / 10) % 10;
    uint8_t ones = score % 10;
    displaySet(tens, ones);
  }



  // Health checks can always run
  if (now - hA.lastCheck >= HEALTH_PERIOD_MS) { hA.lastCheck = now; checkHealth(ADDR_A, hA, "MPU A"); }
  if (now - hB.lastCheck >= HEALTH_PERIOD_MS) { hB.lastCheck = now; checkHealth(ADDR_B, hB, "MPU B"); }

  // ---- Game-over FAIL blink override ----
  bool isGameOverBlink = (demo_phase == DEMO_DONE && game_over);
  if (isGameOverBlink) {
    // Ignore any leftover pass/fail pulses and health status while blinking
    pass_pulse = false;
    fail_pulse = false;
    digitalWrite(LED_PASS, LOW);
    bool on = ((now / GAMEOVER_BLINK_MS) % 2);
    digitalWrite(LED_FAIL, on ? HIGH : LOW);
  }


  // end pulses when time is up (only if not in game-over blink)
  if (!isGameOverBlink) {
    if (pass_pulse && (long)(now - pass_until) >= 0) {
      pass_pulse = false;
      digitalWrite(LED_PASS, LOW);
    }
    if (fail_pulse && (long)(now - fail_until) >= 0) {
      fail_pulse = false;
      digitalWrite(LED_FAIL, LOW);
    }

    // If no active pulse, fall back to health blink status
    if (!pass_pulse) {
      bool aFailBlink = (!hA.healthy) && ((now / FAIL_BLINK_MS) % 2);
      digitalWrite(LED_PASS, aFailBlink ? HIGH : LOW);
    }
    if (!fail_pulse) {
      bool bFailBlink = (!hB.healthy) && ((now / FAIL_BLINK_MS) % 2);
      digitalWrite(LED_FAIL, bFailBlink ? HIGH : LOW);
    }
  }

  // If not started, force LEDs off and DON'T update kinematics
  if (!game_started) {
    // clearFwdLEDs(true); clearFwdLEDs(false);
    // digitalWrite(LED_PULL_BACK, LOW);
    // keep states inert until start
    sA.g_init = sB.g_init = false;     // prevent auto-seed in punch()
    return;
  }

  // ---- Live game path (only runs after Start) ----
  if (wantReseedA && hA.healthy) { wantReseedA = false; seedGravity(mpuA, sA, "A (auto-reseed)", ORIENT_A); }
  if (wantReseedB && hB.healthy) { wantReseedB = false; seedGravity(mpuB, sB, "B (auto-reseed)", ORIENT_B); }

  punch(mpuA, sA, hA, true,  ORIENT_A);
  punch(mpuB, sB, hB, false, ORIENT_B);
  guard(sA, sB, hA, hB, now);

  // --- Guided demo: check required actions and advance phases ---
  if (demo_phase != DEMO_IDLE) {   // <-- was: != DEMO_IDLE && != DEMO_DONE
    unsigned long nowMs = millis();
    unsigned long elapsed = nowMs - phase_t0;

    // detect edges (set true only when it turns on)
    bool punchA_edge = (sA.punch_on && !prevPunchA);
    bool punchB_edge = (sB.punch_on && !prevPunchB);
    bool guard_edge  = (guard_on     && !prevGuard);

    prevPunchA = sA.punch_on;
    prevPunchB = sB.punch_on;
    prevGuard  = guard_on;

    switch (demo_phase) {
      case DEMO_ON: {
        // compute elapsed for this ON window
        if (elapsed > DEMO_ON_MS) {
          // timeout = fail, count round, go to BREAK/DONE
          triggerFail();
          fails++;
          rounds++;
          setTempLEDs(false, false);
          // NEW: kill any residual punch state before leaving ON
          quieten(sA); quieten(sB);

          bool hitFailLimit  = (fails  >= MAX_FAILS);
          bool hitRoundLimit = (rounds >= MAX_ROUNDS);
          demo_phase = (hitFailLimit || hitRoundLimit) ? DEMO_DONE : DEMO_BREAK;
          game_over  = hitFailLimit;
          phase_t0   = nowMs;
          guard_on = false;
          guard_rearm_until = nowMs + GUARD_REARM_MS;
          break;

        }

        // EARLY EXIT on first correct/wrong action depending on target
        bool correct = false, wrong = false;
        if (target == TGT_A) {
          if (punchA_edge) correct = true;
          else if (punchB_edge || guard_edge) wrong = true;
        } else if (target == TGT_B) {
          if (punchB_edge) correct = true;
          else if (punchA_edge || guard_edge) wrong = true;
        } else { // TGT_PB
          if (guard_edge) correct = true;
          else if (punchA_edge || punchB_edge) wrong = true;
        }

        if (correct) {
          score++;
          triggerPass();
          rounds++;
          setTempLEDs(false, false);
          // NEW:
          quieten(sA); quieten(sB);

          bool hitRoundLimit = (rounds >= MAX_ROUNDS);
          demo_phase = hitRoundLimit ? DEMO_DONE : DEMO_BREAK;
          game_over  = false;
          phase_t0   = nowMs;
          guard_on = false;
          guard_rearm_until = nowMs + GUARD_REARM_MS;
          break;

        }
        if (wrong) {
          triggerFail();
          fails++;
          rounds++;
          setTempLEDs(false, false);
          // NEW:
          quieten(sA); quieten(sB);

          bool hitFailLimit  = (fails  >= MAX_FAILS);
          bool hitRoundLimit = (rounds >= MAX_ROUNDS);
          demo_phase = (hitFailLimit || hitRoundLimit) ? DEMO_DONE : DEMO_BREAK;
          game_over  = hitFailLimit;
          phase_t0   = nowMs;
          break;
        }
      } break;

      case DEMO_BREAK:
        if (elapsed >= DEMO_BREAK_MS) {
          // pick a new random target and start next round
          target = (DemoTarget)random(0, 3);
          setTargetLEDs(target);
          demo_phase = DEMO_ON;
          phase_t0 = nowMs;
          guard_on = false;
          guard_rearm_until = nowMs + GUARD_REARM_MS;
          sA.vx_pb = 0; sA.pbx *= 0.5f;   // soften residual PB
          sB.vx_pb = 0; sB.pbx *= 0.5f;
          // reset edge trackers so we don't count stale highs
          prevPunchA = prevPunchB = prevGuard = false;
        }
        break;

      case DEMO_DONE: {
        if (game_over) {
          // continuous blink on both LEDs 9 & 10
          bool on = ((nowMs / GAMEOVER_BLINK_MS) % 2);
          setTempLEDs(on, on);
        } else {
          // finished the 103 rounds without hitting fail limit: stay off
          setTempLEDs(false, false);
        }
      } break;

      default: break;
    }
  }

}
