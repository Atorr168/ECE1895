// Two MPU6050 accel→LEDs with gravity removal + hysteresis + magnitude + hold-time
// MPU A -> LEDs D6/D7/D8;  MPU B -> LEDs D9/D10/D11

#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <math.h>

// ----- SENSORS -----
Adafruit_MPU6050 mpuA;   // address 0x68 (AD0=GND)
Adafruit_MPU6050 mpuB;   // address 0x69 (AD0=VCC)

// ----- CONFIG -----
// const int LEDA_X = 6,  LEDA_Y = 7,  LEDA_Z = 8;   // LEDs for sensor A
// const int LEDB_X = 3,  LEDB_Y = 4, LEDB_Z = 5;  // LEDs for sensor B

// Linear acceleration thresholds (after gravity removal)
const float THRESH_ON  = 1.2f;   // ~0.12 g — moderate hand shake
const float THRESH_OFF = 0.8f;   // hysteresis
float alpha = 0.95f;             // gravity LPF factor

const uint16_t HOLD_MS = 150;    // keep LEDs on briefly so they're visible

// Per-sensor gravity estimate/state
struct GravState {
  bool g_init = false;
  float gx = 0, gy = 0, gz = 0;
  bool x_on = false, y_on = false, z_on = false;
  unsigned long tX = 0, tY = 0, tZ = 0;
};
GravState sA, sB;

// ---------- helpers ----------
void ledInit() {
  int pins[] = {LEDA_X, LEDA_Y, LEDA_Z, LEDB_X, LEDB_Y, LEDB_Z};
  for (int p : pins) { pinMode(p, OUTPUT); digitalWrite(p, LOW); }
  delay(150);
  for (int p : pins) digitalWrite(p, HIGH);
  delay(150);
  for (int p : pins) digitalWrite(p, LOW);
}

bool beginMPU(Adafruit_MPU6050 &mpu, uint8_t addr) {
  if (!mpu.begin(addr)) return false;
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  return true;
}

// Process one sensor: read, remove gravity, apply hysteresis/hold, drive its LEDs
void processOne(Adafruit_MPU6050 &mpu, GravState &st, int Lx, int Ly, int Lz, const char *tag) {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  if (!st.g_init) {
    st.gx = a.acceleration.x; st.gy = a.acceleration.y; st.gz = a.acceleration.z;
    st.g_init = true;
  }

  // Low-pass to estimate gravity
  st.gx = alpha * st.gx + (1.0f - alpha) * a.acceleration.x;
  st.gy = alpha * st.gy + (1.0f - alpha) * a.acceleration.y;
  st.gz = alpha * st.gz + (1.0f - alpha) * a.acceleration.z;

  // Linear acceleration
  float lx = a.acceleration.x - st.gx;
  float ly = a.acceleration.y - st.gy;
  float lz = a.acceleration.z - st.gz;

  float ax = fabs(lx), ay = fabs(ly), az = fabs(lz);
  float amag = sqrt(lx*lx + ly*ly + lz*lz);

  // Per-axis hysteresis + hold
  unsigned long now = millis();
  if (!st.x_on && ax > THRESH_ON) { st.x_on = true; st.tX = now; }
  if ( st.x_on && (ax < THRESH_OFF) && (now - st.tX > HOLD_MS)) st.x_on = false;

  if (!st.y_on && ay > THRESH_ON) { st.y_on = true; st.tY = now; }
  if ( st.y_on && (ay < THRESH_OFF) && (now - st.tY > HOLD_MS)) st.y_on = false;

  if (!st.z_on && az > THRESH_ON) { st.z_on = true; st.tZ = now; }
  if ( st.z_on && (az < THRESH_OFF) && (now - st.tZ > HOLD_MS)) st.z_on = false;

  // Drive LEDs for this sensor
  digitalWrite(Lx, st.x_on ? HIGH : LOW);
  digitalWrite(Ly, st.y_on ? HIGH : LOW);
  digitalWrite(Lz, st.z_on ? HIGH : LOW);

  // Debug (prefix with sensor tag)
  Serial.print(tag); Serial.print(" Lin X:"); Serial.print(lx,2);
  Serial.print(" Y:");  Serial.print(ly,2);
  Serial.print(" Z:");  Serial.print(lz,2);
  Serial.print(" | |a|:"); Serial.println(amag,2);
}

void setup() {
  Serial.begin(115200);
  // while (!Serial) delay(10); // keep disabled for bare 328P
  ledInit();

  // I2C
  Wire.begin();

  // Start both MPUs (A:0x68, B:0x69)
  if (!beginMPU(mpuA, 0x68) || !beginMPU(mpuB, 0x69)) {
    // flash all LEDs rapidly on error
    for (;;) {
      digitalWrite(LEDA_X, !digitalRead(LEDA_X));
      digitalWrite(LEDA_Y, !digitalRead(LEDA_Y));
      digitalWrite(LEDA_Z, !digitalRead(LEDA_Z));
      digitalWrite(LEDB_X, !digitalRead(LEDB_X));
      digitalWrite(LEDB_Y, !digitalRead(LEDB_Y));
      digitalWrite(LEDB_Z, !digitalRead(LEDB_Z));
      delay(150);
    }
  }
  delay(100);
  Serial.println("Dual MPU6050 linear-accel LED demo");
}

void loop() {
  processOne(mpuA, sA, LEDA_X, LEDA_Y, LEDA_Z, "A");
  processOne(mpuB, sB, LEDB_X, LEDB_Y, LEDB_Z, "B");
  delay(20);
}
